%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\chapter{Algèbre linéaire}
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\thispagestyle{empty}
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Modélisation}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\subsection{Contexte}
%--------------------------------------------------------------------------
Dans la plupart des sciences, la modélisation des phénomènes conduit à des fonctions complexes avec lesquelles les calculs sont souvent difficiles, voire impossibles. Une première étape pour le traitement consiste à approcher ces fonctions par des fonctions affines sur des ensembles bornés afin d'employer les outils de l'algèbre linéaire. 

L'outil central consiste alors à résoudre un système linéaire.

\medskip

Cette résolution est aussi importante dans l'étude mathématique :

\begin{itemize}
\item recherche du noyau ou de l'image
\item recherche des coordonnées d'un vecteur dans une base
\item calcul de l'inverse d'une matrice
\item calcul du déterminant
\item calcul des vecteurs propres \dots
\end{itemize}
%--------------------------------------------------------------------------
\subsection{Définitions}
%--------------------------------------------------------------------------
Nous allons considérer qu'on linéarisé le problème ; on est amené à un système de $n$ équations linéaires à $p$ inconnues :

\[\left\{
\begin{matrix}a_{1,1}x_1+a_{1,2}x_2+\cdots+a_{1,p}x_p=b_1\\
a_{2,1}x_1+a_{2,2}x_2+\cdots+a_{2,p}x_p=b_2\\
\cdots\\
a_{n,1}x_1+a_{n,2}x_2+\cdots+a_{n,p}x_p=b_n\\
\end{matrix}\right. 
\]


On associe au système deux matrices : 

\[A=\begin{pmatrix}a_{1,1}&a_{1,2}&\cdots&a_{1,p}\\
a_{2,1}&a_{2,2}&\cdots&a_{2,p}\\
\vdots&\vdots&&\vdots\\
a_{n,1}&a_{n,2}&\cdots&a_{n,p}\\
\end{pmatrix}\in{\cal M}_{n,p}({\R})
\hbox{ et }
B=\begin{pmatrix}b_1\\
b_2\\
\vdots\\
b_n\\
\end{pmatrix}\in{\cal M}_{n,1}({\R})\]

Les valeurs recherchées peuvent être notés matriciellement aussi : $X=\begin{pmatrix}x_1\\
x_2\\
\vdots\\
x_p\\
\end{pmatrix} \in{\cal M}_{p,1}({\R})$.

Résoudre le système consiste à rechercher tous les vecteurs $X$ tels que $A.X=B$.
%--------------------------------------------------------------------------
\subsection{Démarche}
%--------------------------------------------------------------------------
Le principe de la méthode du pivot est de transformer par des étapes simple le système $A.X=B$ en un système $A'.X=B'$ qui admet les mêmes solutions ; l'objectif est d'obtenir un système plus facilement résoluble.

Pour parvenir à ce résultat on va utiliser 3 transformations élémentaires :
\begin{itemize}
\item ajouter un multiple d'une ligne à une autre, c'est une transvection,
\item échanger deux ligne, c'est une permutation,
\item multiplier une ligne par un scalaire {\bf non nul}, c'est une dilatation.
\end{itemize}

On appliquera celles-ci simultanément à la matrice du système, $A$, et au second membre $B$.

Le cours de mathématique montrera (ou a montré) que ces 3 opérations consistent à multiplier à gauche la matrice traitée par une matrice inversible : $A \mapsto T.A=A'$.

Si on note $T_1$, $T_2$, \dots, $T_N$ les matrices correspondant aux transformations successives on a donc

\[ A' = \underbrace{T_N.T_{N-1}.\cdots.T_2.T_1}_{= Q}.A \hbox{ et } B'=Q.B\leqno(\dagger)\]

On sait que si $Q$ est une matrice inversible alors les systèmes $A.X=B$ et $Q.A.X=Q.B$ ont les mêmes solutions.

La forme recherchée de la matrice $A'$ est celle dans laquelle les lignes de commencent par un nombre strictement croissant de 0 : la matrice $A'$ est {\bf échelonnée}. Autrement dit chaque ligne d'indice $i$ commence par $r_i$ termes nuls avec $0\le r_1 < r_2 < \cdots < r_n \le p $. En particulier les termes $a_{i, j}$ avec $i> j$, sous la diagonale, seront nuls. On peut alors étudier les conditions d'existence de solutions et, s'il en existe, l'ensemble des solutions.
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\section{Cas particulier}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
Nous allons en fait nous restreindre à un cas particulier.

Dans toute la suite on supposera que $n=p$ : il y a autant de variables que d'équations.

On supposera aussi que la matrice $A$ est inversible 

On parle dans ce cas d'un {\bf système de Cramer}.

Dans ce cas le système admet une solution unique : $X = A^{-1}.B$.

La méthode du pivot transformera $A$ en une matrice $A$ triangulaire supérieure dont les termes diagonaux sont non nuls, c'est-à-dire à un système de la forme
\[\left\{
\begin{matrix}a'_{1,1}x_1+a'_{1,2}x_2+\cdots+a'_{1,n}x_p=b'_1\\
\hfill a'_{2,2}x_2+\cdots+a'_{2,p}x_p=b'_2\\
\ddots\\
\hfill a'_{n,n}x_n=b'_n\\
\end{matrix}\right. 
\]

On calcule alors facilement la solution :  on détermine $x_n$ puis $x_{n-1}$ en utilisant la valeur de $x_n$ et on remonte ainsi jusqu'à $x_1$. 
\medskip

On peut aller plus loin et transformer une matrice inversible $A$ en $A'=I_n$, le système devient alors $I_n.X=B'$ c'est-à-dire $X=B'$ donc la solution est immédiatement lue.
Cette méthode n'est pas la plus employée car elle demande en fait un peu plus de calculs.
Voir l'exercice \ref{exo:nbcalc}

\newpage
%--------------------------------------------------------------------------
\subsection{Exemple}
%--------------------------------------------------------------------------
Rappelons la méthode du pivot sur un exemple\footnote{L'exemple est un peu artificiel car les coefficients restent entiers.}.

\begin{enumerate}

\item $\left\{
\begin{matrix}x_1&+&x_2&+&x_3&=&2&\\
x_1&+&3x_2&+&3x_3&=&-10&L_2-L_1 \rightarrow L_2\\
2x_1&-&x_2&-&2x_3&=&13&L_3-2L_1 \rightarrow L_3\\
\end{matrix}\right.$
\item $\left\{
\begin{matrix}x_1&+&x_2&+&x_3&=&2&\\
&& 2x_2&+&2x_3&=&-12&\\
&&-3x_2&-&4x_3&=&9&L_3+\frac 32 L_2 \rightarrow L_3\\
\end{matrix}\right.$

\item $\left\{
\begin{matrix}x_1&+&x_2&+&x_3&=&2&\\
&& 2x_2&+&2x_3&=&-12&\\
&&&&-x_3&=&-9&\\
\end{matrix}\right.$
\end{enumerate}
On peut alors déterminer $x_3=9$ puis $x_2=\frac {-12-2x_3}2=-15$ et enfin $x_1=2-x_2-x_3=8$.
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\section{Implémentation classique}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
Dans cette partie, nous allons représenter les vecteurs par des listes et les matrices par des listes de listes. On choisit usuellement de représenter une matrice par la liste de ses lignes, chaque ligne étant elle-même une liste.

Par exemple la matrice $A = \begin{pmatrix}1&3\\ -2&5\\\end{pmatrix}$ est représentée sous la forme
\medskip
\begin{lstlisting}
A = [[1, 3], [-2, 5]]
\end{lstlisting}

En informatique les indices iront de 0 à  $n-1$ : ils décrivent \type{range(n)}.

On accède au terme d'indices \type{i} et \type{j} dans une matrice \type{M} par \type{M[i][j]}.
%--------------------------------------------------------------------------
\subsection{Création de matrice}
%--------------------------------------------------------------------------
On aura besoin de créer une matrice de termes nuls que l'on remplira.

On peut être tenté de définir la matrice nulle de taille $n\times p$ par

\type{ligne = [0]*p}

\type{A = [ligne]*n}

On crée bien $n.p$ termes nuls mais {\bf ils ne sont pas indépendants} : toute modification d'un terme sera répercutée sur toutes les lignes. IL faut créer chaque ligne individuellement.
%--------------------------------------------------------------------------
\begin{lstlisting}
def matriceNulle(n,p):
    A = [0]*n
    for i in range(n):
        A[i] = [0]*p
    return A
\end{lstlisting}
%--------------------------------------------------------------------------
On peut simplifier la construction par une définition de liste par extension
%--------------------------------------------------------------------------
\begin{lstlisting}
def matriceNulle(n,p):
    return [[0]*p for i in range(n)]
\end{lstlisting}
%--------------------------------------------------------------------------
\newpage
%--------------------------------------------------------------------------
\subsection{Matrice augmentée}
%--------------------------------------------------------------------------
Pour ne pas devoir effectuer les transformations sur la matrice $A$ et le vecteur $B$ séparément on les regroupe sous la forme de  matrice augmentée : pour $A\in {\cal M}_{n,p}(\R)$ de coefficients $a_{i,j}$  et $B\in {\cal M}_{n,1}(\R)$ de coefficients $b_i$, la matrice augmentée $(A|B)$ est définie par

\[(A|B)=\begin{pmatrix}a_{1,1}&a_{1,2}&\cdots&a_{1,p}&b_1\\
a_{2,1}&a_{2,2}&\cdots&a_{2,p}&b_2\\
\vdots&\vdots&&\vdots&\vdots\\
a_{n,1}&a_{n,2}&\cdots&a_{n,p}&b_n\\
\end{pmatrix}\in{\cal M}_{n,p+1}({\R})\]

Les transformations produiront la matrice $C' = (A'|B')$.
%--------------------------------------------------------------------------
\subsubsection{Exemple}
%--------------------------------------------------------------------------
L'exemple ci-dessus donne la matrice augmentée
%--------------------------------------------------------------------------
\begin{lstlisting}
[[  1,   1,   1,   2],
 [  1,   3,   3, -10],
 [  2,  -1,  -2,  13]]
\end{lstlisting}
%--------------------------------------------------------------------------
Les transformations successives donneront
%--------------------------------------------------------------------------
\begin{lstlisting}
[[  1,   1,   1,   2],
 [  0,   2,   2, -12],
 [  0,  -3,  -4,   9]]
\end{lstlisting}
%--------------------------------------------------------------------------
puis
%--------------------------------------------------------------------------
\begin{lstlisting}
[[  1,   1,   1,   2],
 [  0,   2,   2, -12],
 [  0,   0,  -1,  -9]]
\end{lstlisting}
%--------------------------------------------------------------------------
\subsubsection{L'algorithme}
%--------------------------------------------------------------------------
\begin{lstlisting}
def fusionner(A,B):
    """Entrées : une matrice A, 
                 une liste B avec autant de lignes que A
       Sortie : la matrice augmentée (A|B)"""
    n = len(A)    # Nombre de lignes de A
    p = len(A[0]) # Nombre de colonnes de A
    C = [0]*n  # Création de n places
    for i in range(n):     # pour chaque ligne
        C[i] = [0]*(p+1)   # on définit une liste
        for j in range(p): # on recopie la ligne de A
            C[i][j] = A[i][j]
        C[i][p] = B[i]     # on place le i-ième terme de B
    return C
\end{lstlisting}
%--------------------------------------------------------------------------
\newpage
%--------------------------------------------------------------------------
\subsection{Transformations élémentaires}
%--------------------------------------------------------------------------
Il reste à écrire les 3 transformations de base. Ces opérations transforment la matrice, elles ne produisent aucun résultat.
\begin{description}
\item[Transvection] On ajoute à une ligne du multiple d'une \textbf{autre} ligne.
%--------------------------------------------------------------------------
\begin{lstlisting}
def combineLignes(M, coef, i0, i):
    p = len(M[0]) 
    for j in range(p):  
        M[i][j] = M[i][j] + coef*M[i0][j]
\end{lstlisting}
%--------------------------------------------------------------------------
\item[Permutation] On échange deux lignes
%--------------------------------------------------------------------------
\begin{lstlisting}
def echangesLignes(M, i1, i2):
    p = len(M[0]) 
    for j in range(p):  
        temp = M[i1][j]
        M[i1][j] = M[i2][j]
        M[i2][j] = temp
\end{lstlisting}
%--------------------------------------------------------------------------
Comme les lignes sont accessibles dans leur ensemble, on peut simplifier
%--------------------------------------------------------------------------
\begin{lstlisting}
def echangesLignes(M, i1, i2):
    ligne_temp = M[i1]
    M[i1] = M[i2]
    M[i2] = ligne_temp
\end{lstlisting}
%--------------------------------------------------------------------------
\item[Dilatation] On multiplie une ligne par un scalaire
%--------------------------------------------------------------------------
\begin{lstlisting}
def multiplieLigne(M, i, coef):
    p = len(M[i])  
    for j in range(p):
        M[i][j] = coef*M[i][j]
\end{lstlisting}
%--------------------------------------------------------------------------
\end{description}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\section{Utilisation de {\sc numpy}}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
{\sc numpy} est le module adapté au calcul vectoriel et aux matrices. On accède au terme d'indices \type{i} et \type{j} dans une matrice \type{M} par \type{M[i][j]} mais aussi avec \type{M[i, j]}.
%--------------------------------------------------------------------------
\subsection{Création de matrice}
%--------------------------------------------------------------------------
\begin{itemize}
\item On peut bien sur convertir une liste de listes.
%--------------------------------------------------------------------------
\begin{lstlisting}
a = np.array([[1.0, 2], [ 3, 4]])
\end{lstlisting}
%--------------------------------------------------------------------------
Noter l'introduction d'au moins 1 flottant qui évite de ne faire que des calculs entiers.
%--------------------------------------------------------------------------
\item Les matrices de même taille peuvent être additionnées et multipliées terme à terme 
\begin{lstlisting}
>>> m+1
array([[2, 3],
       [5, 4]])
>>> m*m
array([[ 1,  4],
       [16,  9]])
\end{lstlisting}
%--------------------------------------------------------------------------
\item La création d'une matrice est immédiatement accessible par la fonction \type{np.zeros} ; comme la fonction n'admet qu'un paramètre pour la taille la création d'une matrice $n\times p$ se fait avec \type{np.zeros((n, p))} ; il y a un double jeu de parenthèses.
%--------------------------------------------------------------------------
\begin{lstlisting}
>>>np.zeros((2,4))
array([[ 0.,  0.,  0.,  0.], [ 0.,  0.,  0.,  0.]])
\end{lstlisting}
%--------------------------------------------------------------------------
\item La taille est donc un tuple que l'on peut obtenir par \type{np.shape}
\begin{lstlisting}
>>> np.shape(am)
(2, 2)
\end{lstlisting}
%--------------------------------------------------------------------------
\item On peut créer une matrice (carrée) identité par {\tt np.eye} :
\begin{lstlisting}
>>> np.eye(3)
array([[ 1.,  0.,  0.], [ 0.,  1.,  0.], [0., 0., 1.]])
\end{lstlisting}
\item Le produit matriciel de \type{a} par \type{b} s'écrit \type{a.dot(b)} ou  \type{np.dot(a, b)}.
\end{itemize}

%--------------------------------------------------------------------------
\subsection{Matrice augmentée}
%--------------------------------------------------------------------------
Dans {\sc numpy} l'extraction peut se faire sur chaque dimension. Par exemple, pour
%--------------------------------------------------------------------------
\begin{lstlisting}
b = np.array([[1.0, 2, 3, 4], [ 5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])
\end{lstlisting}
%--------------------------------------------------------------------------
on peut extraire un rectangle avec \type{b[1 : 3, 0 : 3]} ; on obtient ainsi les lignes d'indices 1 et 2 et les colonnes d'indices 0, 1 et 2.
%--------------------------------------------------------------------------
\begin{lstlisting}
>>> b[1 : 3, 0 : 3]
array([[ 5.,  6.,  7.],
       [ 9., 10., 11.]])
\end{lstlisting}
%--------------------------------------------------------------------------
La fusion peut donc s'écrire
\begin{lstlisting}
def fusionner(A,B):
    """Entrées : une matrice A, 
                 une liste B avec autant de lignes que A
       Sortie : la matrice augmentée (A|B)"""
    n, p = np.shape(A)
    C = np.zeros((n, p+1))
    C[ : , 0 : p] = A
    C[ : , p] = B
    return C
\end{lstlisting}
%--------------------------------------------------------------------------
On notera qu'on a extrait une colonne avec la notation \type{M[ : , k]}.
%--------------------------------------------------------------------------
\subsection{Transformations élémentaires}
%--------------------------------------------------------------------------
Les transformations de base ont une écriture simplifiée car on peut utiliser les lignes en tant que vecteurs. Par contre l'échange de deux lignes demande des précautions : il faut copier la ligne que l'on sauvegarde sinon elle n'est qu'une vue sur la matrice.
%--------------------------------------------------------------------------
\begin{lstlisting}
def combineLignes(M, coef, i0, i):
    M[i] = M[i] + coef*M[i0]
\end{lstlisting}
%--------------------------------------------------------------------------
\begin{lstlisting}
def echangesLignes(M, i1, i2):
    ligne_temp = np.copy(M[i1])
    M[i1] = M[i2]
    M[i2] = ligne_temp
\end{lstlisting}
%--------------------------------------------------------------------------
\begin{lstlisting}
def multiplieLigne(M, i, coef):
   M[i] = coef*M[i]
\end{lstlisting}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\section{Résolution}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\subsection{Solution}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
On commence par la dernière étape : on suppose qu'on est parvenu à un système triangulaire
\[\left\{
\begin{matrix}a'_{1,1}x_1+a'_{1,2}x_2+\cdots+a'_{1,n}x_p=b'_1\\
\hfill a'_{2,2}x_2+\cdots+a'_{2,p}x_p=b'_2\\
\ddots\\
\hfill a'_{n,n}x_n=b'_n\\
\end{matrix}\right. 
\]

On calcule la solution en calculant $x_n$ puis $x_{n-1}$ jusqu'à $x_1$ :
$\displaystyle x_k = \frac 1{a'_{k,k}}\left(b'_k - \sum_{j=k+1}^n a'_{k, j}x_j\right)$.


Comme le système est codé sous la forme d'une matrice augmentée
\[C=\begin{pmatrix}a'_{1,1}&a_{1,2}&\cdots&a'_{1,n}&b'_1\\
a'_{2,1}&a'_{2,2}&\cdots&a'_{2,n}&b'_2\\
\vdots&\vdots&&\vdots&\vdots\\
a'_{n,1}&a'_{n,2}&\cdots&a'_{n,p}&b'_n\\
\end{pmatrix}\in{\cal M}_{n,n+1}({\R})\]

les solutions deviennent $\displaystyle x_k = \frac 1{c_{k,k}}\left(c_{k, n+1} - \sum_{j=k+1}^n c_{k, j}x_j\right)$.

On doit tenir compte du décalage des indices.
%--------------------------------------------------------------------------
\begin{lstlisting}
def solution(C):
    """C est une matrice augmentée formée 
       d'une matrice triangulaire supérieure 
       inversible T et d'un vecteur  B.
       On renvoie la solution de T.X=B."""
    n = len(C)
    X = [0]*n # Tableau des solutions
    for k in range(n-1,-1,-1): 
        X[k]=C[k][n]           
        for j in range(k+1,n):
            X[k]=X[k]-X[j]*C[k][j] 
        X[k]=X[k]/C[k][k]          
    return X
\end{lstlisting}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\subsection{Algorithme naïf}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
La transformation de la matrice en une matrice triangulaire peut être détaillée sous la forme suivante dans laquelle on n'utilise que des transvections.
%--------------------------------------------------------------------------
\begin{lstlisting}
Pour chaque ligne de la première à la dernière, d'indice i
    pour chaque ligne en dessous, d'indice j
        on annule le coefficient C(j, i)
        en retranchant à la ligne d'indice j
                       la ligne d'indice i multipliée par C(j, i)/C(i, i)
\end{lstlisting}
%--------------------------------------------------------------------------
La fonction suit alors la description ci-dessus.

\newpage
%--------------------------------------------------------------------------
\begin{lstlisting}
def resoudreSysteme(A,B):
    """Entrées : une matrice inversible A, une liste B
       Sortie : la solution de A.X=B sous forme de liste"""
    C = fusionner(A,B)
    n = len(C)
    for i in range(n): 
         for j in range(i+1,n):
             coef  = - C[j][i]/C[i][i]
             combineLignes(C, coef, i, j):
    return solution(C)
\end{lstlisting}
%--------------------------------------------------------------------------
Malheureusement l'algorithme ci-dessus ne permet pas toujours de transformer en une matrice triangulaire. On a utilisé le coefficient $c_{i, i}$ qui permet, s'il est non nul, de simplifier les autres termes. Mais ce coefficient, le {\bf pivot} qu'on a choisi, peut être nul.

Par exemple, dans le système  $\left\{
\begin{matrix}\hfill  &&x_2&=&1\\
x_1&+&x_2&=&-1\\
\end{matrix}\right.$ le premier pivot est nul.

Bien entendu on voit qu'il {\em suffit} d'inverser les lignes.
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\subsection{Pivot partiel}
%--------------------------------------------------------------------------
La réponse algorithmique est aussi d'inverser deux lignes en trouvant une ligne dont le terme correspondant (qui sera le pivot choisi) est non nul. Pour trouver cette ligne on recherche dans la colonne d'indice $i$ un indice $j\ge i$ tel que le coefficient est non nul. Il est important de chercher un pivot {\bf en-dessous} de la ligne utilisée car il faut travailler avec une ligne dont les premiers coefficients (jusqu'à $i-1$) sont nuls
%--------------------------------------------------------------------------
\begin{itemize}
\item Si la matrice est inversible on sait qu'un tel indice $j$ existe.

\item Si la matrice n'est pas inversible il existera un indice $i$ pour lequel il n'existe pas de pivot : on peut ainsi tester si une matrice est inversible.
\end{itemize}
%--------------------------------------------------------------------------
Pour trouver le terme correspondant on pourrait chercher le premier terme non nul. 

On peut rendre les calculs plus efficaces ; en effet le choix d'un pivot qui peut être petit risque de donner des multiplications par des grands nombres qui peuvent diminuer la précision des calculs. De plus la comparaison à 0 est peu fiable en raison des problèmes d'arrondis. 

Pour ces raisons on choisira la ligne dont le coefficient sera maximum en valeur absolue : c'est la méthode du {\bf pivot partiel}.

Un autre avantage de cette méthode vient du fait que la nullité de ce pivot équivaut à la nullité de tous les termes donc à la non-inversibilité de la matrice.

\medskip

La recherche du pivot est une recherche classique ; elle renvoie l'indice de la ligne où se trouve le pivot.
%--------------------------------------------------------------------------
\begin{lstlisting}
def lignePivot(M,i):
    n = len(M)
    k = i # le maximum provisoire est en i
    for j in range(i+1,n): # En dessous
        if abs(M[j][i]) > abs(M[k][i]):
            k = j 
    return k
\end{lstlisting}
%--------------------------------------------------------------------------
On peut alors écrire l'algorithme de résolution.

\newpage

%--------------------------------------------------------------------------
\begin{lstlisting}
def resoudreSysteme(A, B):
    """Entrées : une matrice inversible A, 
                 une liste B
       Sortie : la solution de A.X=B sous forme de liste"""
    C = fusion(A, B)
    n = len(C)
    for i in range(n):
         k = lignePivot(C, i)
         if k != i: 
             echangerLignes(C, i, k)
         for j in range(i+1,n):
             k = C[j][i]/C[i][i]
             combinerLigne(C, -k, i, j)
    return solution(C)
\end{lstlisting}
%--------------------------------------------------------------------------
\subsection{Complexité}
%--------------------------------------------------------------------------
On va évaluer la complexité en nombre d'opérations (sommes et produits) nécessaires pour résoudre le système $A.X=B$.
$n$ est le nombre de lignes de $A$.

\begin{itemize}
\item \type{fusionner}, \type{lignePivot}, \type{echangeLignes} n'effectuent pas d'opérations
\item \type{combineLigne} demande $2(n+1)$ opérations et il y a une opération à faire dans l'appel.
\item \type{solution} demande pour chaque $i$, $1+2(n-1-i)+1$ opérations d'où un total de

$\displaystyle \sum_{i=0}^{n-1}2+2(n-1-i)= \sum_{p=0}^{n-1}2+2p=n^2+n$ opérations.
\item La fonction \type{resoudreSysteme} nécessite donc un nombre d'opération, $C(n)$, avec
\begin{align*}
C(n)
&
=\sum_{i=0}^{n-1}\left(1+ \sum_{j=i+1}^{n-1}2(n+1)\right)+n^2+n
=\sum_{i=0}^{n-1} \left(1+2(n-1-i)(n+1)\right)+n^2+n
\\ &
=\sum_{p=0}^{n-1} \left(1+2p(n+1)\right)+n^2+n
=n^3+n^2+n
\end{align*}
\end{itemize}
%--------------------------------------------------------------------------
\begin{center}
\bf La résolution d'un système de Cramer exige un nombre d'opération en ${\cal O}\bigl(n^3\bigr)$.
\end{center}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\subsection{Fonction de bibliothèque}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
Le module {\sc numpy} contient un sous-module, {\sc linalg} qui apporte des fonctions d'algèbre linéaire. 
%--------------------------------------------------------------------------
\begin{lstlisting}
import numpy.linalg as al
\end{lstlisting}
%--------------------------------------------------------------------------
En particulier il fournit la fonction \type{solve} qui correspond à notre fonction \type{resoudreSysteme}.
%--------------------------------------------------------------------------
\newpage
%--------------------------------------------------------------------------
\section{Exercices}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\begin{Exercise}[title = Perte de l'inversibilité]\it 

Le système suivant admet une unique solution, $(2,0,-1)$
$\left\{
\begin{matrix}\hfill x_1+(1+a)x_2+x_3=1\\
x_1+\bigl(1+ \frac 1a\bigr)x_2+2x_3=0\\
\hfill ax_2-x_3=1\\
\end{matrix}\right.$

Tester la fonction \type{resoudreSysteme} pour des grandes valeurs du paramètre $a$.

Que se passe-t-il ?
\end{Exercise}
%--------------------------------------------------------------------------
\begin{Answer}
\begin{lstlisting}
def moche(x):
    return [[1,1+x,1],[1,1+1/x,2],[0,x,-1]]

>>> resoudreSysteme(moche(1E9),[1,0,1])
Traceback (most recent call last):
  [...]
ZeroDivisionError: float division by zero
\end{lstlisting}
Les erreurs d'arrondis font que le programme croit voir un pivot nul.
\end{Answer}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\begin{Exercise}[title = Invention d'une solution]\it 

Le système suivant n'admet pas de solution :
$\left\{
\begin{matrix}\hfill x_1+{1 \over 5}x_2+x_3\hfill=1\\
2x_1+{1 \over 3}x_2\hfill=0\\
15x_1+2x_2-15x_3=1\\
\end{matrix}\right.$

Tester la fonction \type{resoudreSysteme} , que se passe-t-il ?
\end{Exercise}
%--------------------------------------------------------------------------
\begin{Answer}
\begin{lstlisting}
>>> aa=[[1,1/5,1],[2,1/3,0],[15,2,-15]]
>>> resoudreSysteme(aa,[1,0,1])
[-4003199668773774.5, 2.401919801264265e+16, -800639933754754.4]
\end{lstlisting}

Ici les erreurs d'arrondi font qu'un terme qui aurait dû être nul apparaît non nul : le système calcule alors une solution.
\end{Answer}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\begin{Exercise}[label=exo:inv,title=Autre résolution]\it

Écrire une fonction qui résout un système en transformant la matrice $A$ en la matrice identité plutôt qu'en une matrice triangulaire.

\end{Exercise}
%--------------------------------------------------------------------------
\begin{Answer} Le calcul de la solution est plus simple.
%--------------------------------------------------------------------------
\begin{lstlisting}
def derniereColonne(C):
    """Retourne la dernière colonne de C."""
    n = len(C)
    X = []
    for i in range(n): 
        X.append(C[i][-1])
    return X
\end{lstlisting}
%--------------------------------------------------------------------------
Avec numpy, c'est encore plus simple : \type{return C[:,-1]}.

\newpage
%--------------------------------------------------------------------------
\begin{lstlisting}
def resoudreSysteme2(A,B):
    """Entrées : une matrice inversible A, 
                 une liste B
       Sortie : la solution de A.X=B sous forme de liste"""
    C = fusionner(A,B)
    n = len(C)
    for i in range(n):
         k = lignePivot(C,i)
        if k != i: 
            echangeLignes(C,i,k)
         multiplieLigne(C,i,1/C[i][i])
         for j in range(i):
              combineLignes(C,-C[j][i],i,j)
         for j in range(i+1,n):
              combineLignes(C,-C[j][i],i,j)
    X = derniereColonne(C)
    return X
\end{lstlisting}
%--------------------------------------------------------------------------
\end{Answer}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\begin{Exercise}[label=exo:nbcalc,title=Complexité]\it
Calculer le nombre d'opérations (sommes et produits) nécessaires pour résoudre le système $A.X=B$ avec la méthode ci-dessus. Discutez

On exprimera le résultat en fonction du nombre de lignes de $A$, $n$.
\end{Exercise}
%--------------------------------------------------------------------------
\begin{Answer}
\type{multiplieLigne} effectue $n+1$ multiplications.

Il y a donc $n*\bigl(1+(n+1)+(n-1)*2(n+1)\bigr)=2n^3-2n$ opérations. C'est le coefficient de $n^3$ qui fait préférer la méthode classique.
\end{Answer}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\begin{Exercise}[title=Inverse]\it 
En adaptant la méthode du pivot total écrire une fonction qui calcule l'inverse d'une matrice.

On appliquera la méthode de l'exercice \ref{exo:inv} en augmentant la matrice avec la matrice identité.
\end{Exercise}
%--------------------------------------------------------------------------
\begin{Answer}
Si $A'=I_n$ alors $Q=A^{-1}$ d'où $A^{-1}=Q.I_n$. Or $Q.I_n$ est le résultat des opérations $T_1$, $T_2$, \dots, $T_N$ sur la matrice identité. Si on effectue les opérations en même temps sur $A$ et sur $I_n$ pour transformer $A$ en $I_N$ alors $I_n$ sera transformée en $A^{-1}$

\begin{lstlisting}
def inverse(A):
    """Calcul de l'inverse de A"""
    C = ajouterI(A)
    n = len(C)
    for i in range(n):
         k = lignePivot(C,i)
         if k != i: 
             echangeLignes(C,i,k)
         multiplieLigne(C,i,1/C[i][i])
         for j in range(i):
              combineLignes(C,-C[j][i],i,j)
         for j in range(i+1,n):
              combineLignes(C,-C[j][i],i,j)
    AA = fin(C)
    return AA
\end{lstlisting}

\newpage

Il reste à définir les deux fonctions :

\begin{lstlisting}
def ajouterI(A):
    n = len(A)
    C = [0]*n
    for i in range(n):              # Pour chaque ligne
        C[i] = A[i]                 # On copie la ligne de A
        for j in range(n):          # On ajoute n termes
            if j==i: 
                C[i].append(1)      # 1 sur la diagonale
            else:    
                C[i].append(0)      # 0 ailleurs
    return C

def fin(M):
    n = len(M)
    MM = [0]*n
    for i in range(n):
        MM[i] = M[i][n:] # On enlève les n premiers termes
    return MM
\end{lstlisting}
\type{fin} permet aussi de calculer la dernière colonne pour résoudre un système.
\end{Answer}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\begin{Exercise}[title=Déterminant]
\textit{Les transformations élémentaires ont un effet sur le déterminant : 
\begin{itemize}
\item ajouter une multiple d'une ligne à une autre laisse inchangé le déterminant
\item échanger deux ligne multiplie le déterminant par -1
\item multiplier une ligne par un scalaire $\alpha$ multiplie le déterminant par $\alpha$
\end{itemize}
\'Ecrire une fonction qui calcule le déterminant d'une matrice inversible.}
\end{Exercise}
%--------------------------------------------------------------------------
\begin{Answer}
Si on mémorise les modifications du déterminant on obtient à la fin le déterminant de $Q=A^{-1}$ avec les notations de l'exercice ci-dessus.

On n'a pas besoin d'utiliser le pivot total, il suffit d'arriver à une matrice triangulaire avec une diagonale de 1.

Pour gérer le cas des matrices inversibles il suffit de détecter si un pivot est nul et de renvoyer 0 dans ce cas.
%--------------------------------------------------------------------------
\begin{lstlisting}
from copy import deepcopy

def determinant(A):
    """Calcul du déterminant de A"""
    C = deepcopy(A) # On travaille sur une copie
    n = len(C)
    det = 1
    for i in range(n):
        k = lignePivot(C,i)
        if k != i: 
            det = -det
            echangeLignes(C,i,k)
        if C[i][i] == 0:
            return 0
        det = det*C[i][i]
        multiplieLigne(C,i,1/C[i][i])
        for j in range(i+1,n):
            combineLignes(C,-C[j][i],i,j)
    return det
\end{lstlisting}
%--------------------------------------------------------------------------
\newpage
\end{Answer}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\begin{Exercise}[title=Rang]
\textit{Écrire une fonction qui calcule le rang d'une matrice.}
\end{Exercise}
%--------------------------------------------------------------------------
\begin{Answer}
Si un pivot est nul on en cherche un dans la colonne de droite.

On ne travaille plus sur la diagonale : il faut séparer ligne et colonne.

\begin{lstlisting}
from copy import deepcopy

def Pivot(M, i, j):
    """Calcul du maximum dans la colonne j en dessous de i"""
    n = len(M)
    k = i 
    for i1 in range(i+1,n): # En dessous
        if abs(M[i1][j]) > abs(M[k][j]):
            k = i1 
    return k

def rang(M):
    """Calcul du rang de M"""
    A = deepcopy(M)
    n = len(A)
    rg = 0
    col = 0
    while col < n:
        k = Pivot(A, rg, col)
        if k != rg: 
            echangeLignes(A,rg,k)
        pivot = A[rg][col]
        if pivot != 0:
            for j in range(rg+1,n):
                k = -A[j][col]/pivot
                combineLignes(A,k,rg,j)
            rg = rg + 1 # on ne change de ligne que si on a un pivot non nul
        col = col +1    # Par contre on change toujours de colonne   
    return rg
\end{lstlisting}
\end{Answer}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
